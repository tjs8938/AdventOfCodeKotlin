package AdventOfCodeKotlin.puzzles.EverybodyCodes2025

import AdventOfCodeKotlin.util.lcm

class Quest16 {
    companion object {
        fun part1() {
            val spell = "1,3,4,6,7,10,13,14,15,18,21,24,25,28,30,33,36,38,40,42,45".split(",").map { it.toInt() }
            println(spell.sumOf { 90 / it })
        }

        fun part2() {
            val columns = """
                1,2,1,3,1,2,1,4,1,2,1,4,1,2,1,5,1,3,1,3,1,2,2,5,1,2,1,4,2,2,1,5,1,3,1,5,1,2,1,4,1,2,1,3,1,3,1,6,1,2,1,3,1,3,1,5,1,3,1,4,1,2,1,5,1,2,1,4,2,2,1,6,1,2,1,3,1,2,1,5,1,2,1,5,1,2,2,4,1,3,1,4,1,2,1,6,1,2,1,3,1,3,1,4,1,2,1,5,1,2,1,6,1,2,2,4,1,2,1,5,1,2,1,3,1,3,1,5,1,2,1,4,1,2,1,5,1,3,1,4,1,2,1,7,2,2,1,3,1,2,1,4,1,2,1,4,1,2,1,5,2,3,1,3,1,2,1,6,1,3,1,3,1,3,1,5,1,2,1,5,1,2,1,5,1,2,1,3,1,2,1,6,1,2,1,4,1,3,1,4,1,2,2,5,1,2,2,5,1,2,1,3,1,2,1,6,1,2,1,3,1,2,1,6,1,2,1,4,1,3,1,5,1,3,1,3,1,3,1,6,1,2,1,3,1,2,1,4,1,2,1,6,2,2,1,5
            """.trimIndent().split(",").map { it.toInt() }
            val spell = mutableListOf<Int>()
            columns.forEachIndexed { index, blockCount ->
                if (blockCount > spell.count { (index + 1) % it == 0 }) {
                    spell.add(index + 1)
                }
            }
            println(spell.fold(1L) { acc, i -> acc * i })
        }

        fun part3() {
            val columns = """
1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,4,1,2,1,4,2,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,4,1,3,1,2,1,4,1,2,1,4,2,2,1,4,1,2,1,3,1,2,1,4,1,2,2,3,1,2,1,5,1,3,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,6,1,2,1,4,1,2,2,3,1,2,1,4,1,2,1,3,1,2,1,5,1,3,1,3,2,2,1,4,1,2,1,3,1,3,1,4,1,2,1,4,1,2,1,4,1,2,1,3,2,4,1,4,1,2,1,3,2,2,2,5,1,2,1,4,1,3,1,4,1,2,1,3,1,2,2,4,1,2,1,4,1,2,2,4,2,2,1,3,1,2,1,4,1,2,1,3,1,2,1,7,1,2,2,3,2,2,1,4,1,2,1,3,1,3,1,4,1,2,1,4,1,2,1,4,2,2,1,3,1,3,1,4,1,3,1,3,1,2,1,5,1,2,1,4,1,3,1,5,1,4,1,3,1,2,1,4,1,2,1,4,1,2,1,4,1,3,1,4,1,3,1,4,1,2,2,3,1,2,2,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,2,3,1,6,1,2,1,4,2,2,1,3,1,2,1,4,1,3,1,3,1,3,1,5,2,2,1,3,2,2,1,5,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,4,1,2,1,3,1,4,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,3,1,4,1,3,1,3,1,2,2,4,1,2,1,4,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,7,1,3,1,3,1,3,1,4,1,4,1,3,1,2,1,4,1,2,1,4,1,2,1,4,2,2,2,4,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,2,4,1,4,1,3,1,2,1,4,1,2,1,5,2,2,1,4,1,2,1,4,1,2,2,4,1,2,2,3,2,2,1,5,1,2,1,3,1,2,1,5,1,2,1,4,1,2,1,5,1,3,1,6,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,2,2,1,4,1,2,1,4,1,2,2,5,1,2,1,5,1,2,1,4,1,2,1,3,2,4,1,4,1,2,2,3,1,3,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,3,2,4,1,2,1,4,1,2,1,4,1,2,1,3,1,2,1,4,1,3,1,4,1,2,1,7,2,2,1,3,1,2,1,4,2,3,1,3,1,2,2,4,1,2,1,4,1,2,1,4,2,2,1,4,1,2,1,4,1,2,1,4,1,2,1,5,1,3,1,3,1,2,1,4,1,4,1,3,1,2,1,5,1,2,1,4,1,2,1,5,1,2,1,3,1,3,2,4,1,2,2,3,1,2,1,5,1,2,1,3,1,2,1,4,1,3,1,3,1,2,1,4,1,2,1,6,1,3,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,2,2,1,4,1,2,1,4,2,2,1,4,1,3,1,5,1,2,1,5,2,2,1,3,2,4,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,2,4,1,2,1,4,1,2,1,4,2,2,1,3,1,2,1,4,2,2,2,3,1,3,1,7,1,2,1,4,1,2,1,4,1,3,1,4,1,2,1,4,1,2,1,6,1,2,1,4,2,2,1,3,1,3,1,4,1,2,1,3,2,2,1,5,1,2,1,3,1,2,1,4,1,4,1,3,1,3,1,5,1,2,1,4,1,2,1,4,1,2,1,3,1,2,1,4,1,2,2,3,1,2,1,5,1,2,1,3,1,2,2,4,1,2,2,3,1,3,1,4,1,2,1,6,1,3,1,4,1,2,1,3,1,2,1,4,1,2,2,3,1,2,1,6,1,3,1,3,3,2,1,4,1,2,1,3,1,2,1,5,1,3,1,4,1,3,1,4,1,2,1,3,1,4,1,4,2,3,1,3,1,2,1,5,1,2,2,3,1,2,1,4,1,2,1,3,1,2,2,5,1,2,1,4,1,2,1,5,1,2,1,3,1,2,1,5,1,2,1,4,1,2,1,7
            """.trimIndent().split(",").map { it.toInt() }
            val spell = mutableListOf<Long>()
            columns.forEachIndexed { index, blockCount ->
                if (blockCount > spell.count { (index + 1) % it == 0L }) {
                    spell.add(index + 1L)
                }
            }

            val testCases = listOf(
                202520252025000,
            )
            testCases.map { blocks ->
                var minLength = 20000000000000
                var maxLength = 40000000000000

                while (maxLength != minLength) {
                    val maxBlocks = spell.sumOf { maxLength / it }

                    if (maxBlocks < blocks) {
                        minLength = maxLength
                        maxLength *= 2
                    } else {
                        val midLength = (minLength + maxLength) / 2
                        val midBlocks = spell.sumOf { midLength / it }
                        if (midBlocks < blocks) {
                            minLength = midLength
                        } else {
                            maxLength = midLength - 1
                        }
                    }
                }
                maxLength
            }
                .forEach { println(it) }
        }
    }
}

fun main(args: Array<String>) {
    Quest16.part1()
    Quest16.part2()
    Quest16.part3()
}

